export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const cors = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type'
    };
    if (request.method === 'OPTIONS') return new Response(null, { headers: cors });

    const owner  = env.OWNER;
    const repo   = env.REPO;
    const branch = 'main';

    // 공통 헤더 (여기에 User-Agent 추가!)
    const ghHeaders = {
      'Authorization': `Bearer ${env.GITHUB_TOKEN}`,
      'Accept': 'application/vnd.github+json',
      'User-Agent': 'notes-worker/1.0 (+https://kjd1374.github.io/notes/)'
    };

    // --- 진단: 토큰 확인
    if (url.pathname === '/whoami') {
      const r = await fetch('https://api.github.com/user', { headers: ghHeaders });
      const text = await r.text();
      return new Response(text, { status: r.status, headers: { ...cors, 'Content-Type': 'application/json' } });
    }

    // --- 진단: 리포 루트 나열
    if (url.pathname === '/can-list') {
      const ghUrl = `https://api.github.com/repos/${owner}/${repo}/contents?ref=${branch}`;
      const r = await fetch(ghUrl, { headers: ghHeaders });
      const text = await r.text();
      return new Response(text, { status: r.status, headers: { ...cors, 'Content-Type': 'application/json' } });
    }

    // --- 목록: /list?dir=notes
    if (url.pathname === '/list' && request.method === 'GET') {
      const dir = url.searchParams.get('dir') || 'notes';
      const ghUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(dir)}?ref=${branch}`;
      const res = await fetch(ghUrl, { headers: ghHeaders });

      if (res.status === 404) {
        return new Response(JSON.stringify([]), { headers: { ...cors, 'Content-Type': 'application/json' }});
      }
      if (!res.ok) return new Response(await res.text(), { status: res.status, headers: cors });

      const list = await res.json();
      const items = (Array.isArray(list) ? list : [])
        .filter(x => x.type === 'file' && /\.md$/i.test(x.name))
        .map(x => ({ name: x.name, path: x.path, size: x.size || 0 }))
        .sort((a, b) => b.name.localeCompare(a.name));
      return new Response(JSON.stringify(items), { headers: { ...cors, 'Content-Type': 'application/json' }});
    }

    // --- 불러오기: /load?path=notes/inbox.md
    if (url.pathname === '/load' && request.method === 'GET') {
      const path = url.searchParams.get('path');
      if (!path) return new Response('path required', { status: 400, headers: cors });

      const ghUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}?ref=${branch}`;
      const res = await fetch(ghUrl, { headers: ghHeaders });

      if (res.status === 404) {
        return new Response(JSON.stringify({ content: '', sha: null }), { headers: { ...cors, 'Content-Type': 'application/json' }});
      }
      if (!res.ok) return new Response(await res.text(), { status: res.status, headers: cors });

      const data = await res.json();
      const content = data.content ? atob(data.content) : '';
      return new Response(JSON.stringify({ content, sha: data.sha }), { headers: { ...cors, 'Content-Type': 'application/json' }});
    }

    // --- 저장: POST /save { path, content, sha? }
    if (url.pathname === '/save' && request.method === 'POST') {
      const body = await request.json();
      const { path, content, sha } = body || {};
      if (!path || typeof content !== 'string')
        return new Response('path and content required', { status: 400, headers: cors });

      const ghUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;
      const payload = {
        message: `chore(notes): auto-save ${path}`,
        content: btoa(unescape(encodeURIComponent(content))),
        branch
      };
      if (sha) payload.sha = sha;

      const res = await fetch(ghUrl, {
        method: 'PUT',
        headers: { ...ghHeaders, 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!res.ok) return new Response(await res.text(), { status: res.status, headers: cors });

      const data = await res.json();
      const newSha = data.content?.sha || null;
      return new Response(JSON.stringify({ ok: true, sha: newSha }), { headers: { ...cors, 'Content-Type': 'application/json' }});
    }

    // 기본 응답
    return new Response('ok', { headers: cors });
  }
}
